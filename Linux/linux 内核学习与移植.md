# linux 内核学习与移植

标签（空格分隔）： 嵌入式linux

---

## 1. 操作系统基础知识

### 1.1 操作系统的核心功能

- 内存管理

操作系统负责管控所有的内存，所有的应用程序需要使用内存时都要像操作系统去申请和注册，由操作系统的内存管理模块来分配内存给使用，这样的好处是保证内存使用不会冲突。

- 进程调度

进程调度模块负责在各个进程之间进行切换。

- 硬件设备管理

操作系统会去控制各个硬件，应用程序不需要考虑硬件的具体细节，操作系统的硬件设备管理模块就是驱动模块。

- 文件系统

文件系统是管理存储设备的一种方式，存储设备是由多个扇区组成的，有了文件系统之后，人们只关心的文件目录和文件名，而不关心这个文件在物理磁盘的哪个扇区。

### 1.2 操作系统的扩展

- 协议栈

- 有用的应用程序

内核实现操作系统的核心功能，而不包括应用程序，只有内核人事没法用的，因为人做任何事情都是通过相应的应用程序。

### 1.3 内核和驱动的关联

对庞大的整体要有个认识，学习路线就是先建立框架和整体，然后逐渐去学习各个细节部分，逐步细化。

要学着从整体上，从上到下的方式来学习。

注意分层的概念，理解每个东西在哪个层次的哪个地方。

### 1.4 驱动和内核的关系

- 驱动就是内核中的硬件设备管理模块
- 驱动工作在内核态（当前 CPU 正在跑内核代码）

在用户态时，CPU 只能访问允许访问的内存空间。

- 驱动程序故障可能导致整个内核崩溃
- 驱动程序漏洞会使内核不安全

由于应用程序是受限的，所以应用出现问题，不会影响系统中其他应用的运行，系统也不会崩溃。但是如果驱动出错，则可能会导致系统崩溃。

### 1.5 根文件系统

- 为 linux 系统提供根目录，在操作系统中本质上是只有绝对路径的
- 进程 1 存放在根文件系统中，从内核态到用户态的转变，没有根文件系统，就无法转变到用户态
- 内核启动的最后会挂载到根文件系统，根文件系统为操作系统提供根目录

### 1.6 模块化设计

内核中各个功能模块在代码上是彼此独立的，比如调度系统和内存管理系统之间并没有全局变量的互相引用，甚至函数互相调用也很少，就算有也是遵循一个接口规范 。

- 动态升级（动态的安装和卸载）

模块化的编译和安装，为了操作方便，从静态的升级编程了动态的升级，不需要重启系统或者重新烧录系统，这种动态的升级也是由模块化来升级的。

当需要某个驱动的时候，从硬盘中读取并加载到内存中运行，此时操作系统就能支持该设备的驱动了，当设备关闭或者拔出的时候，需要将该驱动从内存中卸载掉。

模块化的好处：

- 功能可裁剪、灵活
- 可扩展性
- 利于协作

模块化设计是一种普遍性的系统设计原则，例如函数、类，组件，操作系统模块等。

### 1.7 如何选择合适的内核版本

- 并不是越新版本的内核越好
- 选择 SOC 厂家一直的版本会减少工作量

### 1.8 S5PV210 适用的内核版本

- 2.6.35.7 + android2.3 + QT4.8.3
- 3.08 + android 4.0

## 2. linux 内核源码目录

建立整体的框架性概念，整体框架比细节更重要。要注意学习的深度，不必特别详细地分析细节代码。

公共的头文件和架构相关的头文件分开存放，架构相关的在 arch/arm/include 文件夹中，公共的头文件存放在 includes 文件夹中。

- lib
在 linux 内核编程中是不能用 c 语言标准库函数的，这里面的函数就是供内核调用的库函数。比如在内核中打印时，要用 printk，而不能用 printf，因为 lib 文件夹中没有 printf。

- mm 
内存管理

- net 
tcp ip 协议栈等

- scripts
内核构建相关的脚本

和我们关系比较大的目录有 arch、deiver 目录。

如果 .config 文件中的配置项为 y，则代码会被加入编译，如果为 n，则不会加入编译。如果为 M，则会被编译成 ko 模块。

## 3. 内核启动过程分析

对整个启动过程有所把握。

make O=xxxx/xx/xxx 在指定目录下输出编译后的文件。

?= 如果没有传参定义就按后面配置的来，如果有传参配置定义，就按传参的配置来。

分析链接脚本的目的是找到整个程序的 entry。

kernel的连接脚本并不是直接提供的，而是提供了一个汇编文件vmlinux.lds.S，然后在编译的时候再去编译这个汇编文件得到真正的链接脚本vmlinux.lds。这样可以用条件编译来配置链接脚本。

### 3.1 head.s 分析

内核运行得物理地址为 0x30008000，虚拟地址为 0xC0008000。

把有相同属性的代码放在一个段中，在链接的时候将他们链接到输出文件的指定位置。可以找到该段的起始地址和结束地址，中间的内容就是存放的该段的代码。

内核的起始部分代码是被解压代码调用的。uboot 启动内核后实际调用运行的是 zImage 前面那一段未经压缩的解压代码，解压代码运行时先将 zImage 后段的内核解压开，然后再去调用运行真正的内核入口。

zImage 是压缩后的 linux 镜像。

内核启动的条件：

- r0 = 0
- r1 = machine nr
- r2 = atags pointer

uboot 最后执行的函数 theKernel 做的事情就是将这三个值放在相应的寄存器中，然后跳转到 kernel 的代码。

在 arm 体系中，函数调用时实际是通过寄存器传参，（函数调用时传参有两种设计：一种是寄存器传参，另一种是用栈内存传参）。

### 3.2 内核启动的汇编阶段

#### 3.2.1 合法性检查

- `__lookup_processor_type`
内核启动前，读出 CPU 的 id 然后和数组中支持的 CPU 进行对比，如果没有一个相等则不合法，如果有一个相等则为合法。

- `__lookup_machine_type`

- `__vet_atags`
检验 uboot 给内核的传参 ATAGS格式是否正确，这里的传参指的是uboot通过 tag 给内核穿的参数。主要是板子的内存分布 memtag、uboot 的 bootargs。

如果 uboot 给内核传参的部分不对，内核是不会启动的。

#### 3.2.2 建立页表

- `__create_page_tables`
创建页表，因为 linux 内核被链接在虚拟地址处，因此内核希望尽快建立页表，开启 MMU。

#### 3.2.3 构建 C 语言运行环境

- `__mmap_switched`
复制数据段、清除 BSS 段，构建 C 语言运行环境，保存 CPU ID 号，机器码，tag 传参的首地址。
b start_kernel 跳转到 C 语言运行阶段。

总结：在内核启动的汇编阶段并没有进行太多工作，主要是因为 UBOOT 已经进行了大部分的工作。汇编阶段主要是校验启动合法性、建立段式映射页表并开启 MMU 以方便使用内存，最后跳入 C 语言阶段。

### 3.3 内核启动的C语言阶段

学习思路：

- 抓大放小，不深究
- 重点局部深入分析

学习方法：

- 顺着代码执行路径抓全局
- 对照内核启动的打印信息进行分析

学习路线：

- 分析 uboot 给 kernel 传参的影响和实现
- 硬件初始化与驱动加载
- 内核启动后的结局

#### 3.3.1 machine 查找代码分析
- `setup_processor` 函数用来查找CPU信息，可以结合串口打印的信息来分析

- `setup_machine` 函数的传参是机器码编号，`machine_arch_type` 符号在`include/generated/mach-types.h`的 32039-32050 行定义了。经过分析后确定这个传参值就是 2456

- 函数的作用是通过传入的机器码编号，找到对应这个机器码的 machine_desc 描述符，并且返回这个描述符的指针

- 其实真正干活的函数是 `lookup_machine_type`，找这个函数发现在 head-common.S 中，真正干活的函数是`__lookup_machine_typ`

- `__lookup_machine_typ`函数的工作原理：内核在建立的时候就把各种CPU架构的信息组织成一个一个的machine_desc 结构体实例，然后都给一个段属性`.arch.info.init`，链接的时候会保证这些描述符会被连接在一起。`__lookup_machine_type`就去那个那些描述符所在处依次挨个遍历各个描述符，对比查看和哪个机器码相同

#### 3.3.2 cmdline 的传递
`setup_arch` 函数进行了基本的 cmdline 处理：

- cmdline

指的 uboot 给 kernel 传参时传递的命令行启动参数，也就是 uboot 的 bootargs。

有几个相关的变量需要注意：

- default_command_line

看名字是默认的命令行参数，实际是一个全局变量字符数组，这个字符数组可以用来存东西

- CONFIG_CMDLINE

在 `.config` 文件中定义的（可以在 make menuconfig 中去更改设置），这个表示内核的一个默认的命令行参数。

- 内核对cmdline的处理思路

内核中自己维护了一个默认的 cmdline（就是.config中配置的这一个），然后 uboot 还可以通过 tag 给 kernel 再传递一个 cmdline。如果 uboot 给内核传 cmdline 成功则内核会优先使用 uboot 传递的这一个。

如果 uboot 没有给内核传 cmdline 或者传参失败，则内核会使用自己默认的这个 cmdline。以上说的这个处理思路就是在 setup_arch 函数中实现的。

实验验证内核的 cmdline 确定：

1. 验证思路：首先给内核配置时配置一个基本的 cmdline，然后在 uboot 启动内核时给 uboot 设置一个 bootargs，然后启动内核看打印出来的 cmdline 和 uboot 传参时是否一样。

2. 在 uboot 中去掉 bootargs，然后再次启动内核看打印出来的 cmdline 是否和内核中设置的默认的 cmdline 一样。

注意：uboot 给内核传递的 cmdline 非常重要，会影响内核的运行，所以要谨慎。有时候内核启动有问题，可以分析下是不是 uboot 的 bootargs 设置不对。

注意：这个传参在这里确定出来之后，后面还会对这个传参进行解析。解析之后 cmdline 中的每一个设置项都会对内核启动有影响。

#### 3.3.3 cmdline 的解析

- setup_command_line

也是在处理和命令行参数cmdline有关的任务。

- parse_early_param&parse_args

解析 cmdline 传参和其他传参，这里的解析意思是把 cmdline 的细节设置信息给解析出来。譬如cmdline：`console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3`，则解析出的内容就是就是一个字符串数组，数组中依次存放了一个设置项目信息。

```
console=ttySAC2,115200  
root=/dev/mmcblk0p2 rw  
init=/linuxrc  
rootfstype=ext3
```

这里只是进行了解析，并没有去处理。也就是说只是把长字符串解析成了短字符串，最多和内核里控制这个相应功能的变量挂钩了，但是并没有去执行。执行的代码在各自模块初始化的代码部分。

#### 3.3.4 start_kernel 中的其他函数

- trap_init					设置异常向量表
- mm_init				     内存管理模块初始化
- sched_init			        内核调度系统初始化
- early_irq_init&init_IRQ	       中断初始化
- console_init				控制台初始化

总结：start_kernel 函数中调用了很多的 xx_init 函数，全都是内核工作需要的模块的初始化函数。这些初始化之后内核就具有了一个基本的可以工作的条件了。

如果把内核比喻成一个复杂机器，那么 start_kernel 函数就是把这个机器的众多零部件组装在一起形成这个机器，让他具有可以工作的基本条件。

- rest_init

这个函数之前内核的基本组装已经完成，剩下的一些工作就比较重要了，放在了一个单独的函数中，叫 rest_init。

总结：start_kernel 函数做的主要工作：打印了一些信息、内核工作需要的模块的初始化被依次调用（譬如内存管理、调度系统、异常处理···）、需要重点了解的就是 setup_arch 中做的2件事情：机器码架构的查找并且执行架构相关的硬件的初始化、uboot 给内核的传参 cmdline。

#### 3.3.5 内核启动后的稳定态

内核启动后的稳定态：

- rest_init 中调用 kernel_thread 函数启动了2个内核线程，分别是：kernel_init 和 kthreadd

- 调用 schedule 函数开启了内核的调度系统，从此linux系统开始转起来了。

- rest_init 最终调用 cpu_idle 函数结束了整个内核的启动过程。也就是说 linux 内核最终结束于函数 cpu_idle，这个函数是一个死循环。

- 简单来说，linux 内核最终的状态是：有事干的时候去执行有意义的工作（执行各个进程任务），实在没活干的时候就去执行 IDLE 死循环。

- 之前已经启动了内核调度系统，调度系统会负责考评系统中所有的进程，这些进程里面只有有哪个需要被运行，调度系统就会终止 cpu_idle 死循环进程（空闲进程）转而去执行有意义的干活的进程。这样操作系统就转起来了。

内核线程：

- 进程和线程。简单来理解，一个运行的程序就是一个进程。所以进程就是任务、进程就是一个独立的程序。独立的意思就是这个程序和别的程序是分开的，这个程序可以被内核单独调用执行或者暂停。

- 在 linux 系统中，线程和进程非常相似，几乎可以看成是一样的。实际上我们当前讲课用到的进程和线程的概念就是一样的。

- 进程/线程就是一个独立的程序。应用层运行一个程序就构成一个用户进程/线程，那么内核中运行一个函数（函数其实就是一个程序）就构成了一个内核进程/线程。

- kernel_thead 函数运行一个函数，其实就是把这个函数变成了一个内核线程去运行起来，然后他可以被内核调度系统去调度。说白了就是去调度器注册了一下，以后人家调度的时候会考虑你。

进程0、进程1、进程2：

- 截至目前为止，我们一共涉及到3个内核进程/线程。
- 操作系统是用一个数字来表示/记录一个进程/线程的，这个数字就被称为这个进程的进程号。这个号码是从 0 开始分配的。因此这里涉及到的三个进程分别是 linux 系统的进程 0、进程 1、进程 2。
- 在 linux 命令行下，使用 ps 命令可以查看当前 linux 系统中运行的进程情况。
- 我们在 ubuntu 下 ps -aux 可以看到当前系统运行的所有进程，可以看出进程号是从 1 开始的。为什么不从 0 开始，因为进程 0 不是一个用户进程，而属于内核进程。

- 三个进程

进程 0：进程 0 其实就是 idle 进程，叫空闲进程，也就是死循环。
进程 1：kernel_init 函数就是进程 1，这个进程被称为 init 进程。
进程 2：kthreadd 函数就是进程 2，这个进程是 linux 内核的守护进程。这个进程是用来保证 linux内核自己本身能正常工作的。

linux 内核启动后达到的一个稳定状态。该稳定状态和 uboot 启动后的稳定状态不一样，内核启动后的稳定状态是其中的任务是可以被任务管理器调度的。而 uboot 启动后的稳定状态就真的是一个死循环了。

关于线程和进程，在目前的阶段是差不多的概念。

每个进程有个进程号，进程号从0开始依次分配的。进程 0 是 idle 进程（ idle 进程是干嘛的）；进程 2 是 ktheadd 进程。后续的功能都在进程1，所以后面要仔细分析进程 1 做的工作。

#### 3.3.6 从内核态到用户态

- init 进程完成了从内核态向用户态的转变

init 进程有 2 种状态，init 进程刚开始运行的时候是内核态，它属于一个内核线程，然后他自己运行了一个用户态下面的程序后把自己强行转成了用户态。因为 init 进程自身完成了从内核态到用户态的过度，因此后续的其他进程都可以工作在用户态下面了。

- 内核态下的工作

在内核态下重点就做了一件事情，就是挂载根文件系统并试图找到用户态下的那个 init 程序。init 进程要把自己转成用户态就必须运行一个用户态的应用程序（这个应用程序名字一般也叫 init ），要运行这个应用程序就必须得找到这个应用程序，要找到它就必须得挂载根文件系统，因为所有的应用程序都在文件系统中。

内核源代码中的所有函数都是内核态下面的，执行任何一个都不能脱离内核态。应用程序必须不属于内核源代码，这样才能保证自己是用户态。也就是说我们这里执行的这个init程序和内核不在一起，他是另外提供的。提供这个 init 程序的那个人就是根文件系统。

- 用户态下的工作

init 进程大部分有意义的工作都是在用户态下进行的。init 进程对我们操作系统的意义在于：其他所有的用户进程都直接或者间接派生自 init 进程。

init 进程在内核态下面时，通过一个函数 kernel_execve 来执行一个用户空间编译连接的应用程序就跳跃到用户态了。注意这个跳跃过程中进程号是没有改变的，所以一直是进程 1。这个跳跃过程是单向的，也就是说一旦执行了 ini t程序转到了用户态下整个操作系统就算真正的运转起来了，以后只能在用户态下工作了，用户态下想要进入内核态只有走 API 这一条路了。

- init 进程构建了用户交互界面

init 进程是其他用户进程的老祖宗。linux 系统中一个进程的创建是通过其父进程创建出来的。根据这个理论只要有一个父进程就能生出一堆子孙进程了。

init 启动了 login 进程、命令行进程、shell 进程。

shell 进程启动了其他用户进程，命令行和 shell 一旦工作了，用户就可以在命令行下通过 ./xx 的方式来执行其他应用程序，每一个应用程序的运行就是一个进程。

- 打开控制台

linux 系统中每个进程都有自己的一个文件描述符表，表中存储的是本进程打开的文件。

linux 系统中有一个设计理念：一切皆是文件。所以设备也是以文件的方式来访问的。我们要访问一个设备，就要去打开这个设备对应的文件描述符。譬如 /dev/fb0 这个设备文件就代表 LCD 显示器设备，/dev/buzzer 代表蜂鸣器设备，/dev/console 代表控制台设备。

打开/dev/console文件，并且复制了2次文件描述符，一共得到了3个文件描述符。这三个文件描述符分别是 0、1、2。这三个文件描述符就是：标准输入、标准输出、标准错误。

进程 1 打开了三个标准输出输出错误文件，因此后续的进程 1 衍生出来的所有的进程默认都具有这 3 个三件描述符。

- 挂载根文件系统

prepare_namespace函数中挂载根文件系统，uboot 通过传参来告诉内核根文件系统在哪里，根文件系统的文件系统类型是什么这些信息。

uboot 传参中的 `root=/dev/mmcblk0p2 rw` 这一句就是告诉内核根文件系统在哪里。

uboot 传参中的 `rootfstype=ext3` 这一句就是告诉内核 rootfs 的类型。

如果内核挂载根文件系统成功，则会打印出：`VFS: Mounted root (ext3 filesystem) on device 179:2`。如果挂载根文件系统失败，则会打印：`No filesystem could mount root, tried:  yaffs2`。

如果内核启动时挂载 rootfs 失败，则后面肯定没法执行了，肯定会死。内核中设置了启动失败休息 5s 自动重启的机制，因此这里会自动重启，所以有时候会有反复重启的情况。

如果挂载 rootfs 失败，可能的原因有：

1. 最常见的错误就是 uboot 的 bootargs 设置不对。
2. rootfs 烧录失败（fastboot 烧录不容易出错，以前是手工烧录很容易出错）
3. rootfs 本身制作失败的。（尤其是自己做的 rootfs，或者别人给的第一次用）

- 执行用户态下的进程1程序

一旦挂载 rootfs 成功，则进入 rootfs 中寻找应用程序的 init 程序，这个程序就是用户空间的进程 1，找到后用 run_init_process 去执行他。

- 确定init程序在哪里的方法

先从 uboot 传参 cmdline 中看有没有指定，如果有指定先执行 cmdline 中指定的程序。cmdline 中的 init=/linuxrc 这个就是指定 rootfs 中哪个程序是 init 程序。这里的指定方式就表示我们 rootfs 的根目录下面有个名字叫 linuxrc 的程序，这个程序就是 init 程序。

如果 uboot 传参 cmdline 中没有 init=xx 或者 cmdline 中指定的这个xx执行失败，还有备用方案。第一备用：/sbin/init，第二备用：/etc/init，第三备用：/bin/init，第四备用：/bin/sh。
如果以上都不成功，则认为启动失败。

#### 3.3.7 cmdline 常用参数

- 格式简介

格式就是由很多个项目用空格隔开依次排列，每个项目中都是项目名=项目值。

整个 cmdline 会被内核启动时解析，解析成一个一个的项目名=项目值的字符串。这些字符串又会被再次解析从而影响启动过程。

- root=

这个是用来指定根文件系统在哪里的，一般格式是 `root=/dev/xxx`（一般如果是 nandflash 上则 `/dev/mtdblock2`，如果是 inand/sd 的话则 `/dev/mmcblk0p2`），如果是 nfs 的 rootfs，则 `root=/dev/nfs`。

- rootfstype=

根文件系统的文件系统类型，一般是jffs2、yaffs2、ext3、ubi。

- console=

控制台信息声明，譬如 `console=/dev/ttySAC0,115200` 表示控制台使用串口 0，波特率是115200。

正常情况下，内核启动的时候会根据 console= 这个项目来初始化硬件，并且重定位 console 到具体的一个串口上，所以这里的传参会影响后续是否能从串口终端上接收到内核的信息。

- mem=

mem= 用来告诉内核当前系统的内存有多少。

- init=

init= 用来指定进程 1 的程序 pathname，一般都是 init=/linuxrc。

- 常见 cmdline

`console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3`

第一种这种方式对应 rootfs 在 SD/iNand/Nand/Nor 等物理存储器上。这种对应产品正式出货工作时的情况。

`root=/dev/nfs nfsroot=192.168.1.141:/root/s3c2440/build_rootfs/aston_rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off  init=/linuxrc console=ttySAC0,115200` 

第二种这种方式对应 rootfs 在 nfs 上，这种在我们做调试的时候经常使用。

#### 3.3.8 内核中架构相关代码分析

内核代码基本分为3块

- arch

本目录下全是cpu架构有关的代码

- drivers

本目录下全是硬件的驱动

- 其他目录下的代码

这些代码都和硬件无关，因此系统移植和驱动开发的时候这些代码几乎都是不用关注和修改的。

架构相关的常用目录名及含义：

- mach（ mach 就是 machine architecture）

arch/arm 目录下的一个 mach-xx 目录就表示一类 machine 的定义，这类 machine 的共同点是都用某一种 cpu 来做主芯片。（譬如 mach-s5pv210 这个文件夹里面都是 s5pv210 这个主芯片的开发板machine）。mach-xx 目录里面的一个 mach-yy.c 文件中定义了一个开发板（一个开发板对应一个机器码），这个是可以被扩展的。

- plat（plat 是 platform 的缩写，含义是平台）

plat在这里可以理解为 SoC，也就是说这个 plat 目录下都是 SoC 里面的一些硬件（内部外设）相关的一些代码。在内核中把 SoC 内部外设相关的硬件操作代码就叫做平台设备驱动。

另外 plat 文件夹中存放的是片上外设的一些配置数据，这体现了数据和驱动分离的思想。

- include

include 目录中的所有代码都是架构相关的头文件，linux 内核通用的头文件在内核源码树根目录下的 include 目录里。

头文件目录 include 有好几个，譬如：

```
    kernel/include		        内核通用头文件
    kernel/arch/arm/include		架构相关的头文件
        kernel/arch/arm/include/asm
            kernel\arch\arm\include\asm\mach
    kernel\arch\arm\mach-s5pv210\include\mach
    kernel\arch\arm\plat-s5p\include\plat
```

内核中包含头文件时有一些格式：

```
#include <linux/kernel.h>		kernel/include/linux/kernel.h
#include <asm/mach/arch.h>		kernel/arch/arm/include/asm/mach/arch.h
#include <asm/setup.h>			kernel\arch\arm\include\asm/setup.h
#include <plat/s5pv210.h>		kernel\arch\arm\plat-s5p\include\plat/s5pv210.h
```

有些同名的头文件是有包含关系的，有时候我们需要包含某个头文件时可能并不是直接包含他，而是包含一个包含了他的头文件。

### 3.4 内核移植过程
```
ARCH            = arm
CROSS_COMPILE   = /usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-
```

- 确定内核的解压缩后的地址和链接地址

根据运行结果，分析发现：linux 内核的自解压代码都没有运行（因为没有看到：Uncompressing Linux... done, booting the kernel.）说明 zImage 根本没有被解压成功，内核代码根本就没有被运行，所以没有输出信息了。所以问题出在解压相关的部分。

问题出在内核配置的解压后代码放置的内存地址处。内核配置的解压地址应该等于连接地址，否则自解压之后内核无法运行。现在问题变成：

1. 内核的连接地址等于多少？
2. 内核中配置的解压地址是多少？

这里面还有个问题：内核的链接地址是一个虚拟地址，而自解压代码解压内核时需要物理地址，因此上面说的等于，其实是链接地址对应的物理地址等于自解压地址。

链接地址和他对应的物理地址在 head.S 中可以查到，分别是 0xC0008000 和 0x30008000。那么自解压代码配置的解压地址应该是 30008000。

自解压代码对应的自解压地址在 `mach/Makefile.boot` 文件中。在其中修改，加入两行：
```
# override for SMDKV210
zreladdr-$(CONFIG_MACH_SMDKV210)	:= 0x30008000
params_phys-$(CONFIG_MACH_SMDKV210)	:= 0x30000100
```

同步代码，并且编译，得到的 zImage 复制到 /tftpboot，然后重新下载运行查看结果。自解压代码解压打印信息已经出来了，但是内核还没运行。后来发现是定义的物理地址不对，从 20000000 改到 30000000 即可。

- 关闭不需要的驱动程序

由于一些驱动无法使用，因此需要在 menuconfig 中关掉这些驱动，然后再重新编译运行。出问题的驱动有电源管理芯片驱动、inand 驱动还有 DM9000 网卡驱动。

### 3.5 实用 led 调试法

整理好 led 操作的代码段，在 head.S 中合适的地方添加 led 这个函数，然后在 head.S 的内核起始运行阶段添加调用 led 函数，然后重新编译内核，运行内核看这段代码有无被运行。

如果被运行了，证明在这个调用 led 的步骤之前的部分都是没问题的，那么如果有错肯定错误在后边；如果没有被运行则证明错误在之前，那么就要去之前的部分 debug。